#!/bin/sh

# IUseArchBTW

prog="IUseArchBTW"

# Values: arch, artix
os=
# Values: systemd, openrc, runit, s6, suite66
init=

language="en_US.UTF-8"
timezone="America/New_York"

# Enable debugging and testing
# Example: sh IUseArchBTW debug
debug=0

for option in $*; do
	case "$option" in
		d | debug)
			debug=1
			set -x
			;;
		*) init="${option}";;
	esac
done

# Check to make sure we have a good init system from passed options
case "$init" in
	""|systemd|openrc|runit|s6|suite66) ;;
	*)
		printf "Bad init system from command-line argument: '%s'\n" "$init" 1>&2
		exit 1
		;;
esac

command_exists() {
	command -v "${1}" > /dev/null 2>&1
}

yes_no() {
	while :; do
		printf "%s " "${1}"
		[ "$2" = no ] && printf "[y/N]: " || printf "[Y/n]: "
		read -r answer
		case "${answer}" in
			[Nn]|[Nn][Oo]) return 1;;
			[Yy]|[Yy][Ee][Ss]) return 0;;
			"") [ "$2" = no ] && return 1 || return 0;;
			*) printf "Please answer [y]es or [n]o\n";;
		esac
	done
}

get_password() {
	printf "Enter Password: "
	stty -echo
	read -r password_input
	stty echo
	printf "\nEnter Password Again: "
	stty -echo
	read -r password_input_again
	stty echo
	printf "\n"

	if [ "${password_input}" = "${password_input_again}" ]; then
		return 0
	else
		printf "Passwords do not match please try again.\n"
		get_password
	fi
}

# Example usage: ask "Hello" "there" "General" "Kenobi"
# Results are stored in the $response variable as you cannot return variables
# Answers ARE case sensitive
# Default answer is argument 1
# This function results in duplicate entry in the list need to find away to
# prevent that to make it look nicer
ask() {
	printf "%s Default: %s " "$*" "$1"
	read answer
	if [ -z "${answer}" ]; then
		response="${1}"
		return 0
	fi
	for i in $*; do
		if [ "${answer}" = "${i}" ]; then
			response="${i}"
			return 0
		fi
	done
	printf "Found no match please try again.\n"
	ask $*
}

mnt_dir="/mnt"
boot_dir="${mnt_dir}/boot"
# Path to check if the system is booted as UEFI or BIOS
efi_path="/sys/firmware/efi/efivars"
# Directory to mount EFI boot data
efi=0
[ -d "${efi_path}" ] && efi=1

# Redirect output to log files
exec 1> >(tee "out.log")
exec 2> >(tee "err.log")

# Test for our init system and distrobution
if command_exists "systemctl"; then
	# Assume it is arch if we have systemd
	os="arch"
	init="systemd"
else
	# Assume it is artix if we have another init system
	os="artix"
	if [ -z "${init}" ]; then
		if command_exists "rc-update"; then
			init="openrc"
		elif command_exists "sv"; then
			init="runit"
		elif command_exists "s6-rc"; then
			init="s6"
		elif command_exists "66-tree"; then
			init="suite66"
		else
			printf "ERROR: Could not detect a supported init system\n" 1>&2
			exit 1
		fi
	fi
fi

# Set os specific variables
# Using eval "${chroot_cmd}" is not a perfect solution but I explicitly control
# the variables so there shouldn't be any errors and the only other option I
# know is to completely rewrite every command with arch-chroot and artix-chroot
# which would be extremely redudant and nightmarish to change
if [ "${os}" = arch ]; then
	su_cmd="sudo"
	chroot_cmd="arch-chroot"
elif [ "${os}" = artix ]; then
	su_cmd="doas"
	chroot_cmd="artix-chroot"
else
	printf "Unknown os: '%s'\n" "${os}" 1>&2
	exit 1
fi

# Print os and init information so user can cancel if they want
printf "Detected operarting system is: '%s'\n" "${os}"
printf "Detected init system is: '%s'\n" "${init}"

# Print os and init information for logging and user interaction
printf "Detected operarting system is: '%s'\n" "${os}"
printf "Detected init system is: '%s'\n" "${init}"
if [ "${debug}" -ne 1 ] && [ "${os}" = artix ]; then
	printf "Select init system. Default option is detected init system.\n"
	ask "${init}" openrc runit s6 suite66
	init="${response}"
	response=
fi

enable_lib32_repos=0
artix_enable_arch_repos=0

if [ "${debug}" -eq 1 ]; then
	# Preset variables for testing
	hostname="IUseArchBTW"
	username="test"
	password="test"
	disk="/dev/sda"
else
	printf "Enter Hostname (Name of the Computer): "
	read -r hostname
	printf "Enter Username: "
	read -r username
	get_password
	password="${password_input}"
	lsblk
	printf "Enter Disk (Example: /dev/sda): "
	read -r disk
	yes_no "Enable 32-bit Repositories?" "no" &&
		enable_lib32_repos=1
	if [ "${os}" = artix ]; then
		yes_no "Enable Arch Linux Repositories?" "no" &&
			artix_enable_arch_repos=1
	fi
fi

if [ "${os}" = arch ]; then
	timedatectl set-ntp true
fi

# Artix throws an error that target disk is in use if there is a swap partition
# on the said target disk. Arch will not though? idk
# Find the swap partition and turn it off
# This will turn off the first active swap partition it finds which may not be
# the right one but not many people will have multiple disks in their machines
# that have active swap partitions on them and who is using my script anyway?
# Wish there was a better way though
if [ "${os}" = artix ]; then
	old_swap="$(swapon --show | awk 'FNR==2{print $1}')"
	if [ -n "${old_swap}" ]; then
		swapoff "${old_swap}"
	fi
fi

# Update package database
pacman -Syy --noconfirm

# Artix does not come with parted on it's base iso so we have to install it
# Artix does come with parted on their DE isos (at least with xfce)
# So check and if it's not available install it
if ! command_exists "parted"; then
	pacman -S parted --noconfirm
fi

# Partitioning (It's annoying)
boot_start_num=1
boot_start="${boot_start_num}MiB"
if [ "${efi}" -eq 1 ]; then
	boot_end_num=$(( ${boot_start_num} + 550 ))
else
	boot_end_num=$(( ${boot_start_num} + 100 ))
fi
boot_end="${boot_end_num}MiB"
# Get size of ram in mebibytes
ram_size="$(free --mebi | awk '/Mem:/ {print $2}')"
swap_end_num=$(( ${boot_end_num} + ${ram_size} ))
swap_end="${swap_end_num}MiB"

boot_part_num=1
swap_part_num=2
root_part_num=3

boot_part="${disk}"
swap_part="${disk}"
root_part="${disk}"
# nvme drives have a "p" in front of the partition number
# https://unix.stackexchange.com/questions/452120/persistent-device-naming-for-nvme-storage-devices
# The NVMe naming standard describes:
# nvme0: first registered device's device controller
# nvme0n1: first registered device's first namespace
# nvme0n1p1: first registered device's first namespace's first partition
if [ "${disk%[0-9]n[0-9]}" = "/dev/nvme" ]; then
	boot_part="${boot_part}p"
	swap_part="${swap_part}p"
	root_part="${root_part}p"
fi
boot_part="${boot_part}${boot_part_num}"
swap_part="${swap_part}${swap_part_num}"
root_part="${root_part}${root_part_num}"

if [ "${efi}" -eq 1 ]; then
	parted --script "${disk}" -- mklabel gpt \
		mkpart BOOTPART fat32 "${boot_start}" "${boot_end}" \
		mkpart SWAPPART linux-swap "${boot_end}" "${swap_end}" \
		mkpart ROOTPART ext4 "${swap_end}" 100% \
		set "${boot_part_num}" esp on || exit 1
else
	parted --script "${disk}" -- mklabel msdos \
		mkpart primary ext4 "${boot_start}" "${boot_end}" \
		mkpart primary linux-swap "${boot_end}" "${swap_end}" \
		mkpart primary ext4 "${swap_end}" 100% \
		set "${boot_part_num}" boot on || exit 1
fi

# Make filesystems
mkfs.ext4 -L ROOT "${root_part}"
mkswap -L SWAP "${swap_part}"

if [ "${efi}" -eq 1 ]; then
	mkfs.fat -F 32 "${boot_part}"
	fatlabel "${boot_part}" BOOT
else
	mkfs.ext4 -L BOOT "${boot_part}"
fi

# Mount partitions
# /dev/disk/by-label sometimes works and sometimes doesn't so just use the
# partition variables I already have instead
mount "${root_part}" "${mnt_dir}"
# Change swap partition permissions default 0755 is insecure
chmod 0600 "${swap_part}"
swapon "${swap_part}"
mkdir -p "${boot_dir}"
mount "${boot_part}" "${boot_dir}"

# Install base system
if [ "${os}" = arch ]; then
	pacstrap "${mnt_dir}" linux linux-firmware base base-devel grub \
		vi networkmanager man-db man-pages openssh iptables git
	if [ "${efi}" -eq 1 ]; then
		pacstrap "${mnt_dir}" efibootmgr
	fi
elif [ "${os}" = artix ]; then
	case "${init}" in
		openrc)
			basestrap "${mnt_dir}" openrc elogind-openrc \
				networkmanager-openrc iptables-openrc openssh-openrc
			;;
		runit)
			basestrap "${mnt_dir}" runit elogind-runit \
				networkmanager-runit iptables-runit openssh-runit
			;;
		s6)
			basestrap "${mnt_dir}" s6-base elogind-s6 \
				networkmanager-s6 iptables-s6 openssh-s6
			;;
		suite66)
			basestrap "${mnt_dir}" suite66-base elogind-suite66 \
				networkmanager-suite66 openssh-suite66
			;;
	esac
	if [ "${efi}" -eq 1 ]; then
		basestrap "${mnt_dir}" efibootmgr
	fi
	basestrap "${mnt_dir}" base grub doas vi man-db man-pages git
	if [ "${su_cmd}" != sudo ]; then
		# Use pacman so we can exclude sudo but get the rest of base-devel
		pacman -S --groups --quiet base-devel | grep -Fvx sudo |
			pacman -S --noconfirm --needed --root "${mnt_dir}" -
	else
		basestrap "${mnt_dir}" base-devel
	fi
	# Need sed for mkinitcpio hook script but since we do not install base-devel
	# group at the same time as linux there is no sed for when the script runs
	# so it fails. Work around is to install linux mkinitcpio script:
	# /usr/share/libalpm/scripts/mkinitcpio-install
	basestrap "${mnt_dir}" linux linux-firmware
fi

# Enable 32-bit repositories
if [ "${enable_lib32_repos}" -eq 1 ]; then
	case "${os}" in
		arch)
			cat <<EOF | tee -a "${mnt_dir}/etc/pacman.conf"

# Enabled by ${prog}
[multilib]
Include = /etc/pacman.d/mirrorlist
EOF
			;;
		artix)
			cat <<EOF | tee -a "${mnt_dir}/etc/pacman.conf"

# Enabled by ${prog}
[lib32]
Include = /etc/pacman.d/mirrorlist
EOF
			;;
	esac
fi

# Enable arch linux repositories is artix linux
if [ "${artix_enable_arch_repos}" -eq 1 ]; then
	basestrap "${mnt_dir}" artix-archlinux-support
cat <<EOF | tee -a "${mnt_dir}/etc/pacman.conf"

# Enabled by ${prog}
# Arch Linux Repositories
#[testing]
#Include = /etc/pacman.d/mirrorlist-arch

[extra]
Include = /etc/pacman.d/mirrorlist-arch

#[community-testing]
#Include = /etc/pacman.d/mirrorlist-arch

[community]
Include = /etc/pacman.d/mirrorlist-arch

#[multilib-testing]
#Include = /etc/pacman.d/mirrorlist-arch

#[multilib]
#Include = /etc/pacman.d/mirrorlist-arch
EOF
	eval "${chroot_cmd}" "${mnt_dir}" pacman-key --populate archlinux
fi

# Generate fstab
case "$os" in
	arch) genfstab -U "${mnt_dir}" | tee "${mnt_dir}/etc/fstab";;
	artix) fstabgen -U "${mnt_dir}" | tee "${mnt_dir}/etc/fstab";;
esac

# Setup hostname
printf "%s\n" "${hostname}" | tee "${mnt_dir}/etc/hostname"
if [ "${init}" = openrc ]; then
	printf "hostname='%s'\n" "${hostname}" | tee "${mnt_dir}/etc/conf.d/hostname"
fi
cat <<EOF | tee "${mnt_dir}/etc/hosts"
127.0.0.1 localhost
::1       localhost
127.0.1.1 ${hostname}.localdomain ${hostname}
EOF

# Set time zone
eval "${chroot_cmd}" "${mnt_dir}" ln -sf /usr/share/zoneinfo/"${timezone}" /etc/localtime
# Run hwclock to generate /etc/adjtime
eval "${chroot_cmd}" "${mnt_dir}" hwclock --systohc

# Locale and Keyboard
printf "%s UTF-8\n" "${language}" | tee "${mnt_dir}/etc/locale.gen"
eval "${chroot_cmd}" "${mnt_dir}" locale-gen
cat <<EOF | tee "${mnt_dir}/etc/locale.conf"
export LANG="${language}"
export LC_COLLATE="C"
EOF
printf "KEYMAP=us\n" | tee "${mnt_dir}/etc/vconsole.conf"
if [ "${os}" = artix ]; then
	printf "KEYMAP=us\n" | tee "${mnt_dir}/etc/conf.d/keymaps"
fi

iptables_file="${mnt_dir}/etc/iptables/iptables.rules"
ip6tables_file="${mnt_dir}/etc/iptables/ip6tables.rules"

# iptables Firewall
cat <<EOF | tee "${iptables_file}"
# Generated by ${prog}
# iptables base configuration
# Allow outgoing connections and deny all incoming connections
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p icmp -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -j REJECT --reject-with tcp-reset
-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable
-A INPUT -j REJECT --reject-with icmp-proto-unreachable
COMMIT
EOF

cat <<EOF | tee "${ip6tables_file}"
# Generated by ${prog}
# ip6tables base configuration
# Deny everything
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*raw
:PREROUTING DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*nat
:PREROUTING DROP [0:0]
:INPUT DROP [0:0]
:OUTPUT DROP [0:0]
:POSTROUTING DROP [0:0]
COMMIT

*security
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*mangle
:PREROUTING DROP [0:0]
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
:POSTROUTING DROP [0:0]
COMMIT
EOF

# Load iptables rules
iptables-restore < "${iptables_file}" ||
	printf "ERROR: iptables not restored\n" 1>&2
ip6tables-restore < "${ip6tables_file}" ||
	printf "ERROR: ip6tables not restored\n" 1>&2

# Enable services on boot
case "${init}" in
	systemd)
		arch-chroot "${mnt_dir}" systemctl enable --now iptables
		arch-chroot "${mnt_dir}" systemctl enable --now ip6tables
		arch-chroot "${mnt_dir}" systemctl enable --now NetworkManager
		;;
	openrc)
		# https://serverfault.com/questions/1059232/what-runlevel-should-ufw-firewall-start-at-in-alpine-linux
		# Networking starts at boot run level so maybe use boot run level instead?
		eval "${chroot_cmd}" "${mnt_dir}" rc-update add iptables default
		eval "${chroot_cmd}" "${mnt_dir}" rc-update add ip6tables default
		eval "${chroot_cmd}" "${mnt_dir}" rc-update add NetworkManager default
		;;
	runit)
		eval "${chroot_cmd}" "${mnt_dir}" \
			ln -s /etc/runit/sv/iptables /etc/runit/runsvdir/default
		eval "${chroot_cmd}" "${mnt_dir}" \
			ln -s /etc/runit/sv/ip6tables /etc/runit/runsvdir/default
		eval "${chroot_cmd}" "${mnt_dir}" \
			ln -s /etc/runit/sv/NetworkManager /etc/runit/runsvdir/default
		;;
	s6)
		eval "${chroot_cmd}" "${mnt_dir}" s6-rc-bundle-update \
			-c /etc/s6/rc/compiled add default iptables
		eval "${chroot_cmd}" "${mnt_dir}" s6-rc-bundle-update \
			-c /etc/s6/rc/compiled add default ip6tables
		eval "${chroot_cmd}" "${mnt_dir}" s6-rc-bundle-update \
			-c /etc/s6/rc/compiled add default NetworkManager
		;;
	suite66)
		# suite66 needs some special setup
		eval "${chroot_cmd}" "${mnt_dir}" 66-tree -n boot
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t boot boot@system
		# Need to create default tree first
		eval "${chroot_cmd}" "${mnt_dir}" 66-tree -ncE default
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t default iptables
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t default ip6tables
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t default NetworkManager
		;;
esac

# Have to add iptables as a module otherwise we get error when shutting down or
# rebooting saying: your kernel lacks iptables support please load appropriate
# kernel modules and try agian ERROR: iptables failed to stop
# So we tell the kernel to load iptables module
# https://forums.funtoo.org/topic/884-about-ip6tables/
# https://forum.artixlinux.org/index.php/topic,2035.0.html
if [ "${init}" = openrc ]; then
	# Tell the kernel to load the ip_tables and ip6_tables modules at boot
	# systemd handles this a different way and it seems the arch kernel is setup
	# to load ip_tables by default but not artix
	printf 'modules="ip_tables ip6_tables"\n' |
		tee -a "${mnt_dir}/etc/conf.d/modules"
	# Save the iptables rules
	eval "${chroot_cmd}" "${mnt_dir}" /etc/init.d/iptables save
	eval "${chroot_cmd}" "${mnt_dir}" /etc/init.d/ip6tables save
fi

if [ "${efi}" -eq 1 ]; then
	eval "${chroot_cmd}" "${mnt_dir}" grub-install --target=x86_64-efi \
		--efi-directory="${boot_dir#${mnt_dir}}" --bootloader-id=grub
else
	# eval "${chroot_cmd}" "${mnt_dir}" grub-install \
	# 	--boot-directory="${boot_dir#${mnt_dir}}" "${disk}"
	eval "${chroot_cmd}" "${mnt_dir}" grub-install "${disk}"
fi
eval "${chroot_cmd}" "${mnt_dir}" grub-mkconfig \
	-o "${boot_dir#${mnt_dir}}/grub/grub.cfg"

# Add user
# kvm needed for QEMU with kvm
# sys group is needed for printing with cups
eval "${chroot_cmd}" "${mnt_dir}" useradd --create-home --user-group \
	--groups wheel,kvm,sys \
	"${username}"
printf "%s:%s" "${username}" "${password}" | chpasswd --root "${mnt_dir}"

case "${su_cmd}" in
	sudo)
		printf "\n%s ALL=(ALL) ALL\n" "${username}" |
			tee -a "${mnt_dir}/etc/sudoers"
		;;
	doas)
		printf "permit persist keepenv %s\n" "${username}" |
			tee "${mnt_dir}/etc/doas.conf"
		;;
	*)
		printf "ERROR: Unsupported or null su_cmd '%s'\n" "${su_cmd}" 1>&2
		;;
esac

# Disable root user
usermod --root "${mnt_dir}" --lock root ||
	printf "ERROR: could not lock root user\n" 1>&2
usermod --root "${mnt_dir}" --expiredate 1 root ||
	printf "ERROR: could not set root user expiredate\n" 1>&2
# Disable ssh with root user
printf "\nPermitRootLogin no\n" | tee -a "${mnt_dir}/etc/ssh/sshd_config" ||
	printf "ERROR: could not disable ssh login with root user\n" 1>&2

if [ "${debug}" -ne 1 ]; then
	umount -R "${mnt_dir}" ||
		printf "ERROR: umount error with '%s'\n" "${mnt_dir}" 1>&2
	swapoff -a ||
		printf "ERROR: swapoff -a error with '%s'\n" "${mnt_dir}" 1>&2
else
	set +x
fi

printf "All Done Hopefully It Works\n"

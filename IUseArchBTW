#!/bin/sh

# IUseArchBTW

prog="IUseArchBTW"

# Enable debugging and testing
# Example: sh IUseArchBTW debug
debug=0
if [ "${1}" = "d" ] || [ "${1}" = "debug" ]; then
	debug=1
	set -x
fi

mnt_dir="/mnt"
if [ "${efi}" -eq 1 ]; then
	boot_dir="${mnt_dir}/boot/efi"
else
	boot_dir="${mnt_dir}/boot"
fi
# Path to check if the system is booted as UEFI or BIOS
efi_path="/sys/firmware/efi/efivars"
# Directory to mount EFI boot data
efi=0
[ -d "${efi_path}" ] && efi=1

enable_lib32_repos=0
artix_enable_arch_repos=0

# Redirect output to log files
exec 1> >(tee "out.log")
exec 2> >(tee "err.log")

# Test for our init system and distrobution
if type "systemctl" > /dev/null 2>&1; then
	# Assume it is arch if we have systemd
	os="arch"
	init="systemd"
else
	# Assume it is artix if we have another init system
	os="artix"
	if type "rc-update" > /dev/null 2>&1; then
		init="openrc"
	elif type "sv" > /dev/null 2>&1; then
		init="runit"
	elif type "s6-rc" > /dev/null 2>&1; then
		init="s6"
	elif type "66-tree" > /dev/null 2>&1; then
		init="suite66"
	else
		printf "Unsupported or unknown init system\n" 1>&2
		exit 1
	fi
fi

# Set os specific variables
# Using eval "${chroot_cmd}" is not a perfect solution but I explicitly control
# the variables so there shouldn't be any errors and the only other option I
# know is to completely rewrite every command with arch-chroot and artix-chroot_cmd
# which would be extremely redudant and nightmarish to change
if [ "${os}" = arch ]; then
	su_cmd="sudo"
	chroot_cmd="arch-chroot"
elif [ "${os}" = artix ]; then
	su_cmd="doas"
	chroot_cmd="artix-chroot"
else
	printf "Unknown os: %s\n" "${os}" 1>&2
	exit 1
fi

yes_no() {
	while :; do
		printf "$* [y/N]: "
		read -r answer
		case "${answer}" in
			# Case insensitive match: n no <nothing>
			[Nn]|[Nn][Oo]|"") return 1;;
			# Case insensitive match: y yes
			[Yy]|[Yy][Ee][Ss]) return 0;;
			*) printf "Please answer [y]es or [n]o\n";;
		esac
	done
}

get_password() {
	printf "Enter Password: "
	stty -echo
	read -r password_input
	stty echo
	printf "\nEnter Password Again: "
	stty -echo
	read -r password_input_again
	stty echo
	printf "\n"

	if [ "${password_input}" = "${password_input_again}" ]; then
		return 0
	else
		printf "\nPasswords do not match please try again.\n"
		get_password
	fi
}

# Print os and init information so user can cancel if they want
printf "Detected operarting system is: %s\n" "${os}"
printf "Detected init system is: %s\n" "${init}"

language="en_US.UTF-8"

if [ "${debug}" -eq 1 ]; then
	# Preset variables for testing
	host_input="IUseArchBTW"
	name_input="test"
	password_input="test"
	disk_input="/dev/sda"
else
	printf "Enter Hostname (Name of the Computer): "
	read -r host_input
	printf "Enter Username: "
	read -r name_input
	get_password
	lsblk
	printf "Enter Disk (Example: /dev/sda): "
	read -r disk_input
	yes_no "Enable 32-bit Repositories?" &&
		enable_lib32_repos=1
	if [ "${os}" = artix ]; then
		yes_no "Enable Arch Linux Repositories?" &&
			artix_enable_arch_repos=1
	fi
fi

if [ "${os}" = arch ]; then
	timedatectl set-ntp true
fi

# Artix throws an error that target disk is in use if there is a swap partition
# on the said target disk. Arch will not though? idk
# Find the swap partition and turn it off
# This will turn off the first active swap partition it finds which may not be
# the right one but not many people will have multiple disks in their machines
# that have active swap partitions on them and who is using my script anyway?
# Wish there was a better way though
if [ "${os}" = artix ]; then
	old_swap="$(swapon --show | awk 'FNR==2{print $1}')"
	if [ -n "${old_swap}" ]; then
		swapoff "${old_swap}"
	fi
fi

# Update package database
pacman -Syy

# Artix does not come with parted on it's base iso so we have to install it
# Artix does come with parted on their DE isos (at least with xfce)
# So check and if it's not available install it
if ! type "parted" > /dev/null 2>&1; then
	pacman -S parted --noconfirm
fi

# Partitioning (It's annoying)
boot_start_num=1
boot_start="${boot_start_num}MiB"
if [ "${efi}" -eq 1 ]; then
	boot_end_num=$(( ${boot_start_num} + 550 ))
else
	boot_end_num=$(( ${boot_start_num} + 5 ))
fi
boot_end="${boot_end_num}MiB"
# Get size of ram in mebibytes
ram_size="$(free --mebi | awk '/Mem:/ {print $2}')"
swap_end_num=$(( ${boot_end_num} + ${ram_size} ))
swap_end="${swap_end_num}MiB"

boot_part_num=1
swap_part_num=2
root_part_num=3

boot_part="${disk_input}${boot_part_num}"
swap_part="${disk_input}${swap_part_num}"
root_part="${disk_input}${root_part_num}"

if [ "${efi}" -eq 1 ]; then
	parted --script "${disk_input}" -- mklabel gpt \
		mkpart EFI fat32 "${boot_start}" "${boot_end}" \
		set "${boot_part_num}" esp on || exit 1
else
	parted --script "${disk_input}" -- mklabel msdos \
		mkpart primary ext4 "${boot_start}" "${boot_end}" \
		set "${boot_part_num}" boot on || exit 1
fi
parted --script "${disk_input}" -- \
	mkpart primary linux-swap "${boot_end}" "${swap_end}" \
	mkpart primary ext4 "${swap_end}" 100% || exit 1

# Mount partitions
mkdir -p "${boot_dir}"
# I have had a great deal of issues using /dev/disk/by-label so just explicitly
# use the partitions by name as I already have the variables available
mount "${boot_part}" "${boot_dir}"
# Change swap partition permissions default 0755 is insecure
chmod 0600 "${swap_part}"
swapon "${swap_part}"
mount "${root_part}" "${mnt_dir}"

# Install base system
if [ "${os}" = arch ]; then
	pacstrap "${mnt_dir}" linux linux-firmware base base-devel grub \
		vi networkmanager man-pages openssh iptables git
	if [ "${efi}" -eq 1 ]; then
		pacstrap "${mnt_dir}" efibootmgr
	fi
elif [ "${os}" = artix ]; then
	# For some reason artix doesn't install man-db by default?
	basestrap "${mnt_dir}" linux linux-firmware base grub \
		doas vi man-pages man-db git
	# Don't install sudo since we are using doas
	# Have to install all members of base-devel manually
	# I have not found a workaround for this yet
	basestrap "${mnt_dir}" autoconf automake binutils bison esysusers \
		etmpfiles fakeroot file findutils flex gawk gcc gettext grep groff gzip \
		libtool m4 make pacman patch pkgconf sed texinfo which
	case "${init}" in
		openrc)
			basestrap "${mnt_dir}" openrc elogind-openrc \
				connman-openrc iptables-openrc openssh-openrc
			;;
		runit)
			basestrap "${mnt_dir}" runit elogind-runit \
				connman-runit iptables-runit openssh-runit
			;;
		s6)
		basestrap "${mnt_dir}" s6-base elogind-s6 \
			connman-s6 iptables-s6 openssh-s6
			;;
		suite66)
			basestrap "${mnt_dir}" suite66-base elogind-suite66 \
				connman-suite66 openssh-suite66
			;;
	esac
	if [ "${efi}" -eq 1 ]; then
		basestrap "${mnt_dir}" efibootmgr
	fi
fi

# Enable 32-bit repositories
if [ "${enable_lib32_repos}" -eq 1 ]; then
	case "${os}" in
		arch)
			printf "# Enabled by ${prog}\n[multilib]\nInclude = /etc/pacman.d/mirrorlist\n" | \
				tee -a "${mnt_dir}/etc/pacman.conf"
			;;
		artix)
			printf "# Enabled by ${prog}\n[lib32]\nInclude = /etc/pacman.d/mirrorlist\n" | \
				tee -a "${mnt_dir}/etc/pacman.conf"
			;;
	esac
fi

# Enable arch linux repositories is artix linux
if [ "${artix_enable_arch_repos}" -eq 1 ]; then
	basestrap "${mnt_dir}" artix-archlinux-support
cat <<EOF | tee -a "${mnt_dir}/etc/pacman.conf"

# Enabled by ${prog}
# ARCH
#[testing]
#Include = /etc/pacman.d/mirrorlist-arch

[extra]
Include = /etc/pacman.d/mirrorlist-arch

#[community-testing]
#Include = /etc/pacman.d/mirrorlist-arch

[community]
Include = /etc/pacman.d/mirrorlist-arch

#[multilib-testing]
#Include = /etc/pacman.d/mirrorlist-arch

#[multilib]
#Include = /etc/pacman.d/mirrorlist-arch
EOF
	eval "${chroot_cmd}" "${mnt_dir}" pacman-key --populate archlinux
fi

# Generate fstab
if [ "${os}" = arch ]; then
	genfstab -U "${mnt_dir}" | tee "${mnt_dir}/etc/fstab"
elif [ "${os}" = artix ]; then
	fstabgen -U "${mnt_dir}" | tee "${mnt_dir}/etc/fstab"
fi

# Setup hostname
printf "%s\n" "${host_input}" | tee "${mnt_dir}/etc/hostname"
cat <<EOF | tee "${mnt_dir}/etc/hosts"
127.0.0.1 localhost
::1       localhost
127.0.1.1 ${host_input}.localdomain ${host_input}
EOF

# Set time zone
eval "${chroot_cmd}" "${mnt_dir}" ln -sf /usr/share/zoneinfo/America/New_York /etc/localtime
# Run hwclock to generate /etc/adjtime
eval "${chroot_cmd}" "${mnt_dir}" hwclock --systohc

# Locale and Keyboard
printf "%s UTF-8\n" "${language}" | tee "${mnt_dir}/etc/locale.gen"
eval "${chroot_cmd}" "${mnt_dir}" locale-gen
cat <<EOF | tee "${mnt_dir}/etc/locale.conf"
export LANG="${language}"
export LC_COLLATE="C"
EOF
printf "KEYMAP=us\n" | tee "${mnt_dir}/etc/conf.d/keymaps" \
	"${mnt_dir}/etc/vconsole.conf"

# iptables Firewall
cat <<EOF | tee "${mnt_dir}/etc/iptables/iptables.rules"
# iptables base configuration
# Allow outgoing connections and deny all incoming connections
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p icmp -j ACCEPT
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -j REJECT --reject-with tcp-reset
-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable
-A INPUT -j REJECT --reject-with icmp-proto-unreachable
COMMIT
EOF

cat <<EOF | tee "${mnt_dir}/etc/iptables/ip6tables.rules"
# ip6tables base configuration
# Deny everything
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*raw
:PREROUTING DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*nat
:PREROUTING DROP [0:0]
:INPUT DROP [0:0]
:OUTPUT DROP [0:0]
:POSTROUTING DROP [0:0]
COMMIT

*security
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
COMMIT

*mangle
:PREROUTING DROP [0:0]
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
:POSTROUTING DROP [0:0]
else
COMMIT
EOF

# Enable services on boot
case "${init}" in
	systemd)
		arch-chroot "${mnt_dir}" systemctl enable --now iptables
		arch-chroot "${mnt_dir}" systemctl enable --now NetworkManager
		;;
	openrc)
		# https://serverfault.com/questions/1059232/what-runlevel-should-ufw-firewall-start-at-in-alpine-linux
		# Networking starts at boot run level so maybe use boot run level instead?
		eval "${chroot_cmd}" "${mnt_dir}" rc-update add iptables default
		eval "${chroot_cmd}" "${mnt_dir}" rc-update add connmand default
		;;
	runit)
		eval "${chroot_cmd}" "${mnt_dir}" \
			ln -s /etc/runit/sv/iptables /etc/runit/runsvdir/default
		eval "${chroot_cmd}" "${mnt_dir}" \
			ln -s /etc/runit/sv/connmand /etc/runit/runsvdir/default
		;;
	s6)
		eval "${chroot_cmd}" "${mnt_dir}" s6-rc-bundle-update \
			-c /etc/s6/rc/compiled add default iptables
		eval "${chroot_cmd}" "${mnt_dir}" s6-rc-bundle-update \
			-c /etc/s6/rc/compiled add default connmand
		;;
	suite66)
		# suite66 needs some special setup
		eval "${chroot_cmd}" "${mnt_dir}" 66-tree -n boot
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t boot boot@system
		# Need to create default tree first
		eval "${chroot_cmd}" "${mnt_dir}" 66-tree -ncE default
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t default iptables
		eval "${chroot_cmd}" "${mnt_dir}" 66-enable -t default connmand
		;;
esac

# Have to add iptables as a module otherwise we get error when shutting down or rebooting saying:
# your kernel lacks iptables support please load appropriate kernel modules and try agian
# ERROR: iptables failed to stop
# So we tell the kernel to load iptables module
# https://forums.funtoo.org/topic/884-about-ip6tables/
# https://forum.artixlinux.org/index.php/topic,2035.0.html
if [ "${os}" = artix ]; then
	# Tell the kernel to load the ip_tables and ip6_tables modules at boot
	# systemd handles this a different way and it seems the arch kernel is setup
	# to load ip_tables be default but not artix
	printf 'modules="ip_tables ip6_tables"\n' | tee -a "${mnt_dir}/etc/conf.d/modules"
	# Save the iptables rulse
	eval "${chroot_cmd}" "${mnt_dir}" /etc/init.d/iptables save
	eval "${chroot_cmd}" "${mnt_dir}" /etc/init.d/ip6tables save
fi

if [ "${efi}" -eq 1 ]; then
	eval "${chroot_cmd}" "${mnt_dir}" grub-install --target=x86_64-efi \
		--efi-directory="${boot_dir#${mnt_dir}}" --bootloader-id=grub --recheck
else
	eval "${chroot_cmd}" "${mnt_dir}" grub-install \
		--boot-directory="${boot_dir#${mnt_dir}}" "${disk_input}" --recheck
fi
eval "${chroot_cmd}" "${mnt_dir}" grub-mkconfig \
	-o "${boot_dir#${mnt_dir}}/grub/grub.cfg"

# Add user
eval "${chroot_cmd}" "${mnt_dir}" useradd --create-home --user-group "${name_input}"
printf "%s:%s" "${name_input}" "${password_input}" | chpasswd --root "${mnt_dir}"

case "${su_cmd}" in
	sudo)
		printf "%s ALL=(ALL) ALL\n" "${name_input}" | tee -a "${mnt_dir}/etc/sudoers"
		;;
	doas)
		printf "permit %s\n" "${name_input}" | tee "${mnt_dir}/etc/doas.conf"
		;;
	*)
		printf "ERROR: Unsupported or null su_cmd '%s'\n" "${su_cmd}" 1>&2
		;;
esac

# Disable root user
printf "%s:%s" "root" "RANDOMNOTHINGNESS" | chpasswd --root "${mnt_dir}"
usermod --root "${mnt_dir}" --lock root ||
	printf "ERROR: could not lock root user\n" 1>&2
usermod --root "${mnt_dir}" --expiredate 1 root ||
	printf "ERROR: could not set root user expiredate\n" 1>&2

umount -R "${mnt_dir}" ||
	printf "ERROR: umount error with '%s'\n" "${mnt_dir}" 1>&2

printf "All Done Hopefully It Works\n"
